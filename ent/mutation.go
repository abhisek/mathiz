// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/abhisek/mathiz/ent/answerevent"
	"github.com/abhisek/mathiz/ent/diagnosisevent"
	"github.com/abhisek/mathiz/ent/llmrequestevent"
	"github.com/abhisek/mathiz/ent/masteryevent"
	"github.com/abhisek/mathiz/ent/predicate"
	"github.com/abhisek/mathiz/ent/schema"
	"github.com/abhisek/mathiz/ent/sessionevent"
	"github.com/abhisek/mathiz/ent/snapshot"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAnswerEvent     = "AnswerEvent"
	TypeDiagnosisEvent  = "DiagnosisEvent"
	TypeLLMRequestEvent = "LLMRequestEvent"
	TypeMasteryEvent    = "MasteryEvent"
	TypeSessionEvent    = "SessionEvent"
	TypeSnapshot        = "Snapshot"
)

// AnswerEventMutation represents an operation that mutates the AnswerEvent nodes in the graph.
type AnswerEventMutation struct {
	config
	op             Op
	typ            string
	id             *int
	sequence       *int64
	addsequence    *int64
	timestamp      *time.Time
	session_id     *string
	skill_id       *string
	tier           *string
	category       *string
	question_text  *string
	correct_answer *string
	learner_answer *string
	correct        *bool
	time_ms        *int
	addtime_ms     *int
	answer_format  *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*AnswerEvent, error)
	predicates     []predicate.AnswerEvent
}

var _ ent.Mutation = (*AnswerEventMutation)(nil)

// answereventOption allows management of the mutation configuration using functional options.
type answereventOption func(*AnswerEventMutation)

// newAnswerEventMutation creates new mutation for the AnswerEvent entity.
func newAnswerEventMutation(c config, op Op, opts ...answereventOption) *AnswerEventMutation {
	m := &AnswerEventMutation{
		config:        c,
		op:            op,
		typ:           TypeAnswerEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAnswerEventID sets the ID field of the mutation.
func withAnswerEventID(id int) answereventOption {
	return func(m *AnswerEventMutation) {
		var (
			err   error
			once  sync.Once
			value *AnswerEvent
		)
		m.oldValue = func(ctx context.Context) (*AnswerEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AnswerEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAnswerEvent sets the old AnswerEvent of the mutation.
func withAnswerEvent(node *AnswerEvent) answereventOption {
	return func(m *AnswerEventMutation) {
		m.oldValue = func(context.Context) (*AnswerEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AnswerEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AnswerEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AnswerEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AnswerEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AnswerEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSequence sets the "sequence" field.
func (m *AnswerEventMutation) SetSequence(i int64) {
	m.sequence = &i
	m.addsequence = nil
}

// Sequence returns the value of the "sequence" field in the mutation.
func (m *AnswerEventMutation) Sequence() (r int64, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequence returns the old "sequence" field's value of the AnswerEvent entity.
// If the AnswerEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnswerEventMutation) OldSequence(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequence: %w", err)
	}
	return oldValue.Sequence, nil
}

// AddSequence adds i to the "sequence" field.
func (m *AnswerEventMutation) AddSequence(i int64) {
	if m.addsequence != nil {
		*m.addsequence += i
	} else {
		m.addsequence = &i
	}
}

// AddedSequence returns the value that was added to the "sequence" field in this mutation.
func (m *AnswerEventMutation) AddedSequence() (r int64, exists bool) {
	v := m.addsequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequence resets all changes to the "sequence" field.
func (m *AnswerEventMutation) ResetSequence() {
	m.sequence = nil
	m.addsequence = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *AnswerEventMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *AnswerEventMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the AnswerEvent entity.
// If the AnswerEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnswerEventMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *AnswerEventMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetSessionID sets the "session_id" field.
func (m *AnswerEventMutation) SetSessionID(s string) {
	m.session_id = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *AnswerEventMutation) SessionID() (r string, exists bool) {
	v := m.session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the AnswerEvent entity.
// If the AnswerEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnswerEventMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *AnswerEventMutation) ResetSessionID() {
	m.session_id = nil
}

// SetSkillID sets the "skill_id" field.
func (m *AnswerEventMutation) SetSkillID(s string) {
	m.skill_id = &s
}

// SkillID returns the value of the "skill_id" field in the mutation.
func (m *AnswerEventMutation) SkillID() (r string, exists bool) {
	v := m.skill_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSkillID returns the old "skill_id" field's value of the AnswerEvent entity.
// If the AnswerEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnswerEventMutation) OldSkillID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkillID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkillID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkillID: %w", err)
	}
	return oldValue.SkillID, nil
}

// ResetSkillID resets all changes to the "skill_id" field.
func (m *AnswerEventMutation) ResetSkillID() {
	m.skill_id = nil
}

// SetTier sets the "tier" field.
func (m *AnswerEventMutation) SetTier(s string) {
	m.tier = &s
}

// Tier returns the value of the "tier" field in the mutation.
func (m *AnswerEventMutation) Tier() (r string, exists bool) {
	v := m.tier
	if v == nil {
		return
	}
	return *v, true
}

// OldTier returns the old "tier" field's value of the AnswerEvent entity.
// If the AnswerEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnswerEventMutation) OldTier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTier: %w", err)
	}
	return oldValue.Tier, nil
}

// ResetTier resets all changes to the "tier" field.
func (m *AnswerEventMutation) ResetTier() {
	m.tier = nil
}

// SetCategory sets the "category" field.
func (m *AnswerEventMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *AnswerEventMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the AnswerEvent entity.
// If the AnswerEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnswerEventMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *AnswerEventMutation) ResetCategory() {
	m.category = nil
}

// SetQuestionText sets the "question_text" field.
func (m *AnswerEventMutation) SetQuestionText(s string) {
	m.question_text = &s
}

// QuestionText returns the value of the "question_text" field in the mutation.
func (m *AnswerEventMutation) QuestionText() (r string, exists bool) {
	v := m.question_text
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionText returns the old "question_text" field's value of the AnswerEvent entity.
// If the AnswerEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnswerEventMutation) OldQuestionText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuestionText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuestionText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionText: %w", err)
	}
	return oldValue.QuestionText, nil
}

// ResetQuestionText resets all changes to the "question_text" field.
func (m *AnswerEventMutation) ResetQuestionText() {
	m.question_text = nil
}

// SetCorrectAnswer sets the "correct_answer" field.
func (m *AnswerEventMutation) SetCorrectAnswer(s string) {
	m.correct_answer = &s
}

// CorrectAnswer returns the value of the "correct_answer" field in the mutation.
func (m *AnswerEventMutation) CorrectAnswer() (r string, exists bool) {
	v := m.correct_answer
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrectAnswer returns the old "correct_answer" field's value of the AnswerEvent entity.
// If the AnswerEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnswerEventMutation) OldCorrectAnswer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrectAnswer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrectAnswer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrectAnswer: %w", err)
	}
	return oldValue.CorrectAnswer, nil
}

// ResetCorrectAnswer resets all changes to the "correct_answer" field.
func (m *AnswerEventMutation) ResetCorrectAnswer() {
	m.correct_answer = nil
}

// SetLearnerAnswer sets the "learner_answer" field.
func (m *AnswerEventMutation) SetLearnerAnswer(s string) {
	m.learner_answer = &s
}

// LearnerAnswer returns the value of the "learner_answer" field in the mutation.
func (m *AnswerEventMutation) LearnerAnswer() (r string, exists bool) {
	v := m.learner_answer
	if v == nil {
		return
	}
	return *v, true
}

// OldLearnerAnswer returns the old "learner_answer" field's value of the AnswerEvent entity.
// If the AnswerEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnswerEventMutation) OldLearnerAnswer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLearnerAnswer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLearnerAnswer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLearnerAnswer: %w", err)
	}
	return oldValue.LearnerAnswer, nil
}

// ResetLearnerAnswer resets all changes to the "learner_answer" field.
func (m *AnswerEventMutation) ResetLearnerAnswer() {
	m.learner_answer = nil
}

// SetCorrect sets the "correct" field.
func (m *AnswerEventMutation) SetCorrect(b bool) {
	m.correct = &b
}

// Correct returns the value of the "correct" field in the mutation.
func (m *AnswerEventMutation) Correct() (r bool, exists bool) {
	v := m.correct
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrect returns the old "correct" field's value of the AnswerEvent entity.
// If the AnswerEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnswerEventMutation) OldCorrect(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrect: %w", err)
	}
	return oldValue.Correct, nil
}

// ResetCorrect resets all changes to the "correct" field.
func (m *AnswerEventMutation) ResetCorrect() {
	m.correct = nil
}

// SetTimeMs sets the "time_ms" field.
func (m *AnswerEventMutation) SetTimeMs(i int) {
	m.time_ms = &i
	m.addtime_ms = nil
}

// TimeMs returns the value of the "time_ms" field in the mutation.
func (m *AnswerEventMutation) TimeMs() (r int, exists bool) {
	v := m.time_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeMs returns the old "time_ms" field's value of the AnswerEvent entity.
// If the AnswerEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnswerEventMutation) OldTimeMs(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeMs: %w", err)
	}
	return oldValue.TimeMs, nil
}

// AddTimeMs adds i to the "time_ms" field.
func (m *AnswerEventMutation) AddTimeMs(i int) {
	if m.addtime_ms != nil {
		*m.addtime_ms += i
	} else {
		m.addtime_ms = &i
	}
}

// AddedTimeMs returns the value that was added to the "time_ms" field in this mutation.
func (m *AnswerEventMutation) AddedTimeMs() (r int, exists bool) {
	v := m.addtime_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeMs resets all changes to the "time_ms" field.
func (m *AnswerEventMutation) ResetTimeMs() {
	m.time_ms = nil
	m.addtime_ms = nil
}

// SetAnswerFormat sets the "answer_format" field.
func (m *AnswerEventMutation) SetAnswerFormat(s string) {
	m.answer_format = &s
}

// AnswerFormat returns the value of the "answer_format" field in the mutation.
func (m *AnswerEventMutation) AnswerFormat() (r string, exists bool) {
	v := m.answer_format
	if v == nil {
		return
	}
	return *v, true
}

// OldAnswerFormat returns the old "answer_format" field's value of the AnswerEvent entity.
// If the AnswerEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnswerEventMutation) OldAnswerFormat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnswerFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnswerFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnswerFormat: %w", err)
	}
	return oldValue.AnswerFormat, nil
}

// ResetAnswerFormat resets all changes to the "answer_format" field.
func (m *AnswerEventMutation) ResetAnswerFormat() {
	m.answer_format = nil
}

// Where appends a list predicates to the AnswerEventMutation builder.
func (m *AnswerEventMutation) Where(ps ...predicate.AnswerEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AnswerEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AnswerEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AnswerEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AnswerEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AnswerEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AnswerEvent).
func (m *AnswerEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AnswerEventMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.sequence != nil {
		fields = append(fields, answerevent.FieldSequence)
	}
	if m.timestamp != nil {
		fields = append(fields, answerevent.FieldTimestamp)
	}
	if m.session_id != nil {
		fields = append(fields, answerevent.FieldSessionID)
	}
	if m.skill_id != nil {
		fields = append(fields, answerevent.FieldSkillID)
	}
	if m.tier != nil {
		fields = append(fields, answerevent.FieldTier)
	}
	if m.category != nil {
		fields = append(fields, answerevent.FieldCategory)
	}
	if m.question_text != nil {
		fields = append(fields, answerevent.FieldQuestionText)
	}
	if m.correct_answer != nil {
		fields = append(fields, answerevent.FieldCorrectAnswer)
	}
	if m.learner_answer != nil {
		fields = append(fields, answerevent.FieldLearnerAnswer)
	}
	if m.correct != nil {
		fields = append(fields, answerevent.FieldCorrect)
	}
	if m.time_ms != nil {
		fields = append(fields, answerevent.FieldTimeMs)
	}
	if m.answer_format != nil {
		fields = append(fields, answerevent.FieldAnswerFormat)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AnswerEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case answerevent.FieldSequence:
		return m.Sequence()
	case answerevent.FieldTimestamp:
		return m.Timestamp()
	case answerevent.FieldSessionID:
		return m.SessionID()
	case answerevent.FieldSkillID:
		return m.SkillID()
	case answerevent.FieldTier:
		return m.Tier()
	case answerevent.FieldCategory:
		return m.Category()
	case answerevent.FieldQuestionText:
		return m.QuestionText()
	case answerevent.FieldCorrectAnswer:
		return m.CorrectAnswer()
	case answerevent.FieldLearnerAnswer:
		return m.LearnerAnswer()
	case answerevent.FieldCorrect:
		return m.Correct()
	case answerevent.FieldTimeMs:
		return m.TimeMs()
	case answerevent.FieldAnswerFormat:
		return m.AnswerFormat()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AnswerEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case answerevent.FieldSequence:
		return m.OldSequence(ctx)
	case answerevent.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case answerevent.FieldSessionID:
		return m.OldSessionID(ctx)
	case answerevent.FieldSkillID:
		return m.OldSkillID(ctx)
	case answerevent.FieldTier:
		return m.OldTier(ctx)
	case answerevent.FieldCategory:
		return m.OldCategory(ctx)
	case answerevent.FieldQuestionText:
		return m.OldQuestionText(ctx)
	case answerevent.FieldCorrectAnswer:
		return m.OldCorrectAnswer(ctx)
	case answerevent.FieldLearnerAnswer:
		return m.OldLearnerAnswer(ctx)
	case answerevent.FieldCorrect:
		return m.OldCorrect(ctx)
	case answerevent.FieldTimeMs:
		return m.OldTimeMs(ctx)
	case answerevent.FieldAnswerFormat:
		return m.OldAnswerFormat(ctx)
	}
	return nil, fmt.Errorf("unknown AnswerEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnswerEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case answerevent.FieldSequence:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequence(v)
		return nil
	case answerevent.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case answerevent.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case answerevent.FieldSkillID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkillID(v)
		return nil
	case answerevent.FieldTier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTier(v)
		return nil
	case answerevent.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case answerevent.FieldQuestionText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionText(v)
		return nil
	case answerevent.FieldCorrectAnswer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrectAnswer(v)
		return nil
	case answerevent.FieldLearnerAnswer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLearnerAnswer(v)
		return nil
	case answerevent.FieldCorrect:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrect(v)
		return nil
	case answerevent.FieldTimeMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeMs(v)
		return nil
	case answerevent.FieldAnswerFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnswerFormat(v)
		return nil
	}
	return fmt.Errorf("unknown AnswerEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AnswerEventMutation) AddedFields() []string {
	var fields []string
	if m.addsequence != nil {
		fields = append(fields, answerevent.FieldSequence)
	}
	if m.addtime_ms != nil {
		fields = append(fields, answerevent.FieldTimeMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AnswerEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case answerevent.FieldSequence:
		return m.AddedSequence()
	case answerevent.FieldTimeMs:
		return m.AddedTimeMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnswerEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case answerevent.FieldSequence:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequence(v)
		return nil
	case answerevent.FieldTimeMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeMs(v)
		return nil
	}
	return fmt.Errorf("unknown AnswerEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AnswerEventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AnswerEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AnswerEventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AnswerEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AnswerEventMutation) ResetField(name string) error {
	switch name {
	case answerevent.FieldSequence:
		m.ResetSequence()
		return nil
	case answerevent.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case answerevent.FieldSessionID:
		m.ResetSessionID()
		return nil
	case answerevent.FieldSkillID:
		m.ResetSkillID()
		return nil
	case answerevent.FieldTier:
		m.ResetTier()
		return nil
	case answerevent.FieldCategory:
		m.ResetCategory()
		return nil
	case answerevent.FieldQuestionText:
		m.ResetQuestionText()
		return nil
	case answerevent.FieldCorrectAnswer:
		m.ResetCorrectAnswer()
		return nil
	case answerevent.FieldLearnerAnswer:
		m.ResetLearnerAnswer()
		return nil
	case answerevent.FieldCorrect:
		m.ResetCorrect()
		return nil
	case answerevent.FieldTimeMs:
		m.ResetTimeMs()
		return nil
	case answerevent.FieldAnswerFormat:
		m.ResetAnswerFormat()
		return nil
	}
	return fmt.Errorf("unknown AnswerEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AnswerEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AnswerEventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AnswerEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AnswerEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AnswerEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AnswerEventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AnswerEventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AnswerEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AnswerEventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AnswerEvent edge %s", name)
}

// DiagnosisEventMutation represents an operation that mutates the DiagnosisEvent nodes in the graph.
type DiagnosisEventMutation struct {
	config
	op               Op
	typ              string
	id               *int
	sequence         *int64
	addsequence      *int64
	timestamp        *time.Time
	session_id       *string
	skill_id         *string
	question_text    *string
	correct_answer   *string
	learner_answer   *string
	category         *string
	misconception_id *string
	confidence       *float64
	addconfidence    *float64
	classifier_name  *string
	reasoning        *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*DiagnosisEvent, error)
	predicates       []predicate.DiagnosisEvent
}

var _ ent.Mutation = (*DiagnosisEventMutation)(nil)

// diagnosiseventOption allows management of the mutation configuration using functional options.
type diagnosiseventOption func(*DiagnosisEventMutation)

// newDiagnosisEventMutation creates new mutation for the DiagnosisEvent entity.
func newDiagnosisEventMutation(c config, op Op, opts ...diagnosiseventOption) *DiagnosisEventMutation {
	m := &DiagnosisEventMutation{
		config:        c,
		op:            op,
		typ:           TypeDiagnosisEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiagnosisEventID sets the ID field of the mutation.
func withDiagnosisEventID(id int) diagnosiseventOption {
	return func(m *DiagnosisEventMutation) {
		var (
			err   error
			once  sync.Once
			value *DiagnosisEvent
		)
		m.oldValue = func(ctx context.Context) (*DiagnosisEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DiagnosisEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDiagnosisEvent sets the old DiagnosisEvent of the mutation.
func withDiagnosisEvent(node *DiagnosisEvent) diagnosiseventOption {
	return func(m *DiagnosisEventMutation) {
		m.oldValue = func(context.Context) (*DiagnosisEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiagnosisEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiagnosisEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DiagnosisEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DiagnosisEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DiagnosisEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSequence sets the "sequence" field.
func (m *DiagnosisEventMutation) SetSequence(i int64) {
	m.sequence = &i
	m.addsequence = nil
}

// Sequence returns the value of the "sequence" field in the mutation.
func (m *DiagnosisEventMutation) Sequence() (r int64, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequence returns the old "sequence" field's value of the DiagnosisEvent entity.
// If the DiagnosisEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosisEventMutation) OldSequence(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequence: %w", err)
	}
	return oldValue.Sequence, nil
}

// AddSequence adds i to the "sequence" field.
func (m *DiagnosisEventMutation) AddSequence(i int64) {
	if m.addsequence != nil {
		*m.addsequence += i
	} else {
		m.addsequence = &i
	}
}

// AddedSequence returns the value that was added to the "sequence" field in this mutation.
func (m *DiagnosisEventMutation) AddedSequence() (r int64, exists bool) {
	v := m.addsequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequence resets all changes to the "sequence" field.
func (m *DiagnosisEventMutation) ResetSequence() {
	m.sequence = nil
	m.addsequence = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *DiagnosisEventMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *DiagnosisEventMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the DiagnosisEvent entity.
// If the DiagnosisEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosisEventMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *DiagnosisEventMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetSessionID sets the "session_id" field.
func (m *DiagnosisEventMutation) SetSessionID(s string) {
	m.session_id = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *DiagnosisEventMutation) SessionID() (r string, exists bool) {
	v := m.session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the DiagnosisEvent entity.
// If the DiagnosisEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosisEventMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *DiagnosisEventMutation) ResetSessionID() {
	m.session_id = nil
}

// SetSkillID sets the "skill_id" field.
func (m *DiagnosisEventMutation) SetSkillID(s string) {
	m.skill_id = &s
}

// SkillID returns the value of the "skill_id" field in the mutation.
func (m *DiagnosisEventMutation) SkillID() (r string, exists bool) {
	v := m.skill_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSkillID returns the old "skill_id" field's value of the DiagnosisEvent entity.
// If the DiagnosisEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosisEventMutation) OldSkillID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkillID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkillID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkillID: %w", err)
	}
	return oldValue.SkillID, nil
}

// ResetSkillID resets all changes to the "skill_id" field.
func (m *DiagnosisEventMutation) ResetSkillID() {
	m.skill_id = nil
}

// SetQuestionText sets the "question_text" field.
func (m *DiagnosisEventMutation) SetQuestionText(s string) {
	m.question_text = &s
}

// QuestionText returns the value of the "question_text" field in the mutation.
func (m *DiagnosisEventMutation) QuestionText() (r string, exists bool) {
	v := m.question_text
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionText returns the old "question_text" field's value of the DiagnosisEvent entity.
// If the DiagnosisEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosisEventMutation) OldQuestionText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuestionText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuestionText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionText: %w", err)
	}
	return oldValue.QuestionText, nil
}

// ResetQuestionText resets all changes to the "question_text" field.
func (m *DiagnosisEventMutation) ResetQuestionText() {
	m.question_text = nil
}

// SetCorrectAnswer sets the "correct_answer" field.
func (m *DiagnosisEventMutation) SetCorrectAnswer(s string) {
	m.correct_answer = &s
}

// CorrectAnswer returns the value of the "correct_answer" field in the mutation.
func (m *DiagnosisEventMutation) CorrectAnswer() (r string, exists bool) {
	v := m.correct_answer
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrectAnswer returns the old "correct_answer" field's value of the DiagnosisEvent entity.
// If the DiagnosisEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosisEventMutation) OldCorrectAnswer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrectAnswer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrectAnswer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrectAnswer: %w", err)
	}
	return oldValue.CorrectAnswer, nil
}

// ResetCorrectAnswer resets all changes to the "correct_answer" field.
func (m *DiagnosisEventMutation) ResetCorrectAnswer() {
	m.correct_answer = nil
}

// SetLearnerAnswer sets the "learner_answer" field.
func (m *DiagnosisEventMutation) SetLearnerAnswer(s string) {
	m.learner_answer = &s
}

// LearnerAnswer returns the value of the "learner_answer" field in the mutation.
func (m *DiagnosisEventMutation) LearnerAnswer() (r string, exists bool) {
	v := m.learner_answer
	if v == nil {
		return
	}
	return *v, true
}

// OldLearnerAnswer returns the old "learner_answer" field's value of the DiagnosisEvent entity.
// If the DiagnosisEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosisEventMutation) OldLearnerAnswer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLearnerAnswer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLearnerAnswer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLearnerAnswer: %w", err)
	}
	return oldValue.LearnerAnswer, nil
}

// ResetLearnerAnswer resets all changes to the "learner_answer" field.
func (m *DiagnosisEventMutation) ResetLearnerAnswer() {
	m.learner_answer = nil
}

// SetCategory sets the "category" field.
func (m *DiagnosisEventMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *DiagnosisEventMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the DiagnosisEvent entity.
// If the DiagnosisEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosisEventMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *DiagnosisEventMutation) ResetCategory() {
	m.category = nil
}

// SetMisconceptionID sets the "misconception_id" field.
func (m *DiagnosisEventMutation) SetMisconceptionID(s string) {
	m.misconception_id = &s
}

// MisconceptionID returns the value of the "misconception_id" field in the mutation.
func (m *DiagnosisEventMutation) MisconceptionID() (r string, exists bool) {
	v := m.misconception_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMisconceptionID returns the old "misconception_id" field's value of the DiagnosisEvent entity.
// If the DiagnosisEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosisEventMutation) OldMisconceptionID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMisconceptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMisconceptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMisconceptionID: %w", err)
	}
	return oldValue.MisconceptionID, nil
}

// ClearMisconceptionID clears the value of the "misconception_id" field.
func (m *DiagnosisEventMutation) ClearMisconceptionID() {
	m.misconception_id = nil
	m.clearedFields[diagnosisevent.FieldMisconceptionID] = struct{}{}
}

// MisconceptionIDCleared returns if the "misconception_id" field was cleared in this mutation.
func (m *DiagnosisEventMutation) MisconceptionIDCleared() bool {
	_, ok := m.clearedFields[diagnosisevent.FieldMisconceptionID]
	return ok
}

// ResetMisconceptionID resets all changes to the "misconception_id" field.
func (m *DiagnosisEventMutation) ResetMisconceptionID() {
	m.misconception_id = nil
	delete(m.clearedFields, diagnosisevent.FieldMisconceptionID)
}

// SetConfidence sets the "confidence" field.
func (m *DiagnosisEventMutation) SetConfidence(f float64) {
	m.confidence = &f
	m.addconfidence = nil
}

// Confidence returns the value of the "confidence" field in the mutation.
func (m *DiagnosisEventMutation) Confidence() (r float64, exists bool) {
	v := m.confidence
	if v == nil {
		return
	}
	return *v, true
}

// OldConfidence returns the old "confidence" field's value of the DiagnosisEvent entity.
// If the DiagnosisEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosisEventMutation) OldConfidence(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfidence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfidence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfidence: %w", err)
	}
	return oldValue.Confidence, nil
}

// AddConfidence adds f to the "confidence" field.
func (m *DiagnosisEventMutation) AddConfidence(f float64) {
	if m.addconfidence != nil {
		*m.addconfidence += f
	} else {
		m.addconfidence = &f
	}
}

// AddedConfidence returns the value that was added to the "confidence" field in this mutation.
func (m *DiagnosisEventMutation) AddedConfidence() (r float64, exists bool) {
	v := m.addconfidence
	if v == nil {
		return
	}
	return *v, true
}

// ResetConfidence resets all changes to the "confidence" field.
func (m *DiagnosisEventMutation) ResetConfidence() {
	m.confidence = nil
	m.addconfidence = nil
}

// SetClassifierName sets the "classifier_name" field.
func (m *DiagnosisEventMutation) SetClassifierName(s string) {
	m.classifier_name = &s
}

// ClassifierName returns the value of the "classifier_name" field in the mutation.
func (m *DiagnosisEventMutation) ClassifierName() (r string, exists bool) {
	v := m.classifier_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClassifierName returns the old "classifier_name" field's value of the DiagnosisEvent entity.
// If the DiagnosisEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosisEventMutation) OldClassifierName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassifierName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassifierName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassifierName: %w", err)
	}
	return oldValue.ClassifierName, nil
}

// ResetClassifierName resets all changes to the "classifier_name" field.
func (m *DiagnosisEventMutation) ResetClassifierName() {
	m.classifier_name = nil
}

// SetReasoning sets the "reasoning" field.
func (m *DiagnosisEventMutation) SetReasoning(s string) {
	m.reasoning = &s
}

// Reasoning returns the value of the "reasoning" field in the mutation.
func (m *DiagnosisEventMutation) Reasoning() (r string, exists bool) {
	v := m.reasoning
	if v == nil {
		return
	}
	return *v, true
}

// OldReasoning returns the old "reasoning" field's value of the DiagnosisEvent entity.
// If the DiagnosisEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosisEventMutation) OldReasoning(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReasoning is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReasoning requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReasoning: %w", err)
	}
	return oldValue.Reasoning, nil
}

// ClearReasoning clears the value of the "reasoning" field.
func (m *DiagnosisEventMutation) ClearReasoning() {
	m.reasoning = nil
	m.clearedFields[diagnosisevent.FieldReasoning] = struct{}{}
}

// ReasoningCleared returns if the "reasoning" field was cleared in this mutation.
func (m *DiagnosisEventMutation) ReasoningCleared() bool {
	_, ok := m.clearedFields[diagnosisevent.FieldReasoning]
	return ok
}

// ResetReasoning resets all changes to the "reasoning" field.
func (m *DiagnosisEventMutation) ResetReasoning() {
	m.reasoning = nil
	delete(m.clearedFields, diagnosisevent.FieldReasoning)
}

// Where appends a list predicates to the DiagnosisEventMutation builder.
func (m *DiagnosisEventMutation) Where(ps ...predicate.DiagnosisEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DiagnosisEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DiagnosisEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DiagnosisEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DiagnosisEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DiagnosisEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DiagnosisEvent).
func (m *DiagnosisEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DiagnosisEventMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.sequence != nil {
		fields = append(fields, diagnosisevent.FieldSequence)
	}
	if m.timestamp != nil {
		fields = append(fields, diagnosisevent.FieldTimestamp)
	}
	if m.session_id != nil {
		fields = append(fields, diagnosisevent.FieldSessionID)
	}
	if m.skill_id != nil {
		fields = append(fields, diagnosisevent.FieldSkillID)
	}
	if m.question_text != nil {
		fields = append(fields, diagnosisevent.FieldQuestionText)
	}
	if m.correct_answer != nil {
		fields = append(fields, diagnosisevent.FieldCorrectAnswer)
	}
	if m.learner_answer != nil {
		fields = append(fields, diagnosisevent.FieldLearnerAnswer)
	}
	if m.category != nil {
		fields = append(fields, diagnosisevent.FieldCategory)
	}
	if m.misconception_id != nil {
		fields = append(fields, diagnosisevent.FieldMisconceptionID)
	}
	if m.confidence != nil {
		fields = append(fields, diagnosisevent.FieldConfidence)
	}
	if m.classifier_name != nil {
		fields = append(fields, diagnosisevent.FieldClassifierName)
	}
	if m.reasoning != nil {
		fields = append(fields, diagnosisevent.FieldReasoning)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DiagnosisEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case diagnosisevent.FieldSequence:
		return m.Sequence()
	case diagnosisevent.FieldTimestamp:
		return m.Timestamp()
	case diagnosisevent.FieldSessionID:
		return m.SessionID()
	case diagnosisevent.FieldSkillID:
		return m.SkillID()
	case diagnosisevent.FieldQuestionText:
		return m.QuestionText()
	case diagnosisevent.FieldCorrectAnswer:
		return m.CorrectAnswer()
	case diagnosisevent.FieldLearnerAnswer:
		return m.LearnerAnswer()
	case diagnosisevent.FieldCategory:
		return m.Category()
	case diagnosisevent.FieldMisconceptionID:
		return m.MisconceptionID()
	case diagnosisevent.FieldConfidence:
		return m.Confidence()
	case diagnosisevent.FieldClassifierName:
		return m.ClassifierName()
	case diagnosisevent.FieldReasoning:
		return m.Reasoning()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DiagnosisEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case diagnosisevent.FieldSequence:
		return m.OldSequence(ctx)
	case diagnosisevent.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case diagnosisevent.FieldSessionID:
		return m.OldSessionID(ctx)
	case diagnosisevent.FieldSkillID:
		return m.OldSkillID(ctx)
	case diagnosisevent.FieldQuestionText:
		return m.OldQuestionText(ctx)
	case diagnosisevent.FieldCorrectAnswer:
		return m.OldCorrectAnswer(ctx)
	case diagnosisevent.FieldLearnerAnswer:
		return m.OldLearnerAnswer(ctx)
	case diagnosisevent.FieldCategory:
		return m.OldCategory(ctx)
	case diagnosisevent.FieldMisconceptionID:
		return m.OldMisconceptionID(ctx)
	case diagnosisevent.FieldConfidence:
		return m.OldConfidence(ctx)
	case diagnosisevent.FieldClassifierName:
		return m.OldClassifierName(ctx)
	case diagnosisevent.FieldReasoning:
		return m.OldReasoning(ctx)
	}
	return nil, fmt.Errorf("unknown DiagnosisEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiagnosisEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case diagnosisevent.FieldSequence:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequence(v)
		return nil
	case diagnosisevent.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case diagnosisevent.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case diagnosisevent.FieldSkillID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkillID(v)
		return nil
	case diagnosisevent.FieldQuestionText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionText(v)
		return nil
	case diagnosisevent.FieldCorrectAnswer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrectAnswer(v)
		return nil
	case diagnosisevent.FieldLearnerAnswer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLearnerAnswer(v)
		return nil
	case diagnosisevent.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case diagnosisevent.FieldMisconceptionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMisconceptionID(v)
		return nil
	case diagnosisevent.FieldConfidence:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfidence(v)
		return nil
	case diagnosisevent.FieldClassifierName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassifierName(v)
		return nil
	case diagnosisevent.FieldReasoning:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReasoning(v)
		return nil
	}
	return fmt.Errorf("unknown DiagnosisEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DiagnosisEventMutation) AddedFields() []string {
	var fields []string
	if m.addsequence != nil {
		fields = append(fields, diagnosisevent.FieldSequence)
	}
	if m.addconfidence != nil {
		fields = append(fields, diagnosisevent.FieldConfidence)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DiagnosisEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case diagnosisevent.FieldSequence:
		return m.AddedSequence()
	case diagnosisevent.FieldConfidence:
		return m.AddedConfidence()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiagnosisEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case diagnosisevent.FieldSequence:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequence(v)
		return nil
	case diagnosisevent.FieldConfidence:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConfidence(v)
		return nil
	}
	return fmt.Errorf("unknown DiagnosisEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DiagnosisEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(diagnosisevent.FieldMisconceptionID) {
		fields = append(fields, diagnosisevent.FieldMisconceptionID)
	}
	if m.FieldCleared(diagnosisevent.FieldReasoning) {
		fields = append(fields, diagnosisevent.FieldReasoning)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DiagnosisEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiagnosisEventMutation) ClearField(name string) error {
	switch name {
	case diagnosisevent.FieldMisconceptionID:
		m.ClearMisconceptionID()
		return nil
	case diagnosisevent.FieldReasoning:
		m.ClearReasoning()
		return nil
	}
	return fmt.Errorf("unknown DiagnosisEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DiagnosisEventMutation) ResetField(name string) error {
	switch name {
	case diagnosisevent.FieldSequence:
		m.ResetSequence()
		return nil
	case diagnosisevent.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case diagnosisevent.FieldSessionID:
		m.ResetSessionID()
		return nil
	case diagnosisevent.FieldSkillID:
		m.ResetSkillID()
		return nil
	case diagnosisevent.FieldQuestionText:
		m.ResetQuestionText()
		return nil
	case diagnosisevent.FieldCorrectAnswer:
		m.ResetCorrectAnswer()
		return nil
	case diagnosisevent.FieldLearnerAnswer:
		m.ResetLearnerAnswer()
		return nil
	case diagnosisevent.FieldCategory:
		m.ResetCategory()
		return nil
	case diagnosisevent.FieldMisconceptionID:
		m.ResetMisconceptionID()
		return nil
	case diagnosisevent.FieldConfidence:
		m.ResetConfidence()
		return nil
	case diagnosisevent.FieldClassifierName:
		m.ResetClassifierName()
		return nil
	case diagnosisevent.FieldReasoning:
		m.ResetReasoning()
		return nil
	}
	return fmt.Errorf("unknown DiagnosisEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DiagnosisEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DiagnosisEventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DiagnosisEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DiagnosisEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DiagnosisEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DiagnosisEventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DiagnosisEventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DiagnosisEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DiagnosisEventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DiagnosisEvent edge %s", name)
}

// LLMRequestEventMutation represents an operation that mutates the LLMRequestEvent nodes in the graph.
type LLMRequestEventMutation struct {
	config
	op               Op
	typ              string
	id               *int
	sequence         *int64
	addsequence      *int64
	timestamp        *time.Time
	provider         *string
	model            *string
	purpose          *string
	input_tokens     *int
	addinput_tokens  *int
	output_tokens    *int
	addoutput_tokens *int
	latency_ms       *int64
	addlatency_ms    *int64
	success          *bool
	error_message    *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*LLMRequestEvent, error)
	predicates       []predicate.LLMRequestEvent
}

var _ ent.Mutation = (*LLMRequestEventMutation)(nil)

// llmrequesteventOption allows management of the mutation configuration using functional options.
type llmrequesteventOption func(*LLMRequestEventMutation)

// newLLMRequestEventMutation creates new mutation for the LLMRequestEvent entity.
func newLLMRequestEventMutation(c config, op Op, opts ...llmrequesteventOption) *LLMRequestEventMutation {
	m := &LLMRequestEventMutation{
		config:        c,
		op:            op,
		typ:           TypeLLMRequestEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLLMRequestEventID sets the ID field of the mutation.
func withLLMRequestEventID(id int) llmrequesteventOption {
	return func(m *LLMRequestEventMutation) {
		var (
			err   error
			once  sync.Once
			value *LLMRequestEvent
		)
		m.oldValue = func(ctx context.Context) (*LLMRequestEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LLMRequestEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLLMRequestEvent sets the old LLMRequestEvent of the mutation.
func withLLMRequestEvent(node *LLMRequestEvent) llmrequesteventOption {
	return func(m *LLMRequestEventMutation) {
		m.oldValue = func(context.Context) (*LLMRequestEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LLMRequestEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LLMRequestEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LLMRequestEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LLMRequestEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LLMRequestEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSequence sets the "sequence" field.
func (m *LLMRequestEventMutation) SetSequence(i int64) {
	m.sequence = &i
	m.addsequence = nil
}

// Sequence returns the value of the "sequence" field in the mutation.
func (m *LLMRequestEventMutation) Sequence() (r int64, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequence returns the old "sequence" field's value of the LLMRequestEvent entity.
// If the LLMRequestEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMRequestEventMutation) OldSequence(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequence: %w", err)
	}
	return oldValue.Sequence, nil
}

// AddSequence adds i to the "sequence" field.
func (m *LLMRequestEventMutation) AddSequence(i int64) {
	if m.addsequence != nil {
		*m.addsequence += i
	} else {
		m.addsequence = &i
	}
}

// AddedSequence returns the value that was added to the "sequence" field in this mutation.
func (m *LLMRequestEventMutation) AddedSequence() (r int64, exists bool) {
	v := m.addsequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequence resets all changes to the "sequence" field.
func (m *LLMRequestEventMutation) ResetSequence() {
	m.sequence = nil
	m.addsequence = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *LLMRequestEventMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *LLMRequestEventMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the LLMRequestEvent entity.
// If the LLMRequestEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMRequestEventMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *LLMRequestEventMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetProvider sets the "provider" field.
func (m *LLMRequestEventMutation) SetProvider(s string) {
	m.provider = &s
}

// Provider returns the value of the "provider" field in the mutation.
func (m *LLMRequestEventMutation) Provider() (r string, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the LLMRequestEvent entity.
// If the LLMRequestEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMRequestEventMutation) OldProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *LLMRequestEventMutation) ResetProvider() {
	m.provider = nil
}

// SetModel sets the "model" field.
func (m *LLMRequestEventMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *LLMRequestEventMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the LLMRequestEvent entity.
// If the LLMRequestEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMRequestEventMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *LLMRequestEventMutation) ResetModel() {
	m.model = nil
}

// SetPurpose sets the "purpose" field.
func (m *LLMRequestEventMutation) SetPurpose(s string) {
	m.purpose = &s
}

// Purpose returns the value of the "purpose" field in the mutation.
func (m *LLMRequestEventMutation) Purpose() (r string, exists bool) {
	v := m.purpose
	if v == nil {
		return
	}
	return *v, true
}

// OldPurpose returns the old "purpose" field's value of the LLMRequestEvent entity.
// If the LLMRequestEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMRequestEventMutation) OldPurpose(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurpose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurpose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurpose: %w", err)
	}
	return oldValue.Purpose, nil
}

// ResetPurpose resets all changes to the "purpose" field.
func (m *LLMRequestEventMutation) ResetPurpose() {
	m.purpose = nil
}

// SetInputTokens sets the "input_tokens" field.
func (m *LLMRequestEventMutation) SetInputTokens(i int) {
	m.input_tokens = &i
	m.addinput_tokens = nil
}

// InputTokens returns the value of the "input_tokens" field in the mutation.
func (m *LLMRequestEventMutation) InputTokens() (r int, exists bool) {
	v := m.input_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldInputTokens returns the old "input_tokens" field's value of the LLMRequestEvent entity.
// If the LLMRequestEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMRequestEventMutation) OldInputTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputTokens: %w", err)
	}
	return oldValue.InputTokens, nil
}

// AddInputTokens adds i to the "input_tokens" field.
func (m *LLMRequestEventMutation) AddInputTokens(i int) {
	if m.addinput_tokens != nil {
		*m.addinput_tokens += i
	} else {
		m.addinput_tokens = &i
	}
}

// AddedInputTokens returns the value that was added to the "input_tokens" field in this mutation.
func (m *LLMRequestEventMutation) AddedInputTokens() (r int, exists bool) {
	v := m.addinput_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetInputTokens resets all changes to the "input_tokens" field.
func (m *LLMRequestEventMutation) ResetInputTokens() {
	m.input_tokens = nil
	m.addinput_tokens = nil
}

// SetOutputTokens sets the "output_tokens" field.
func (m *LLMRequestEventMutation) SetOutputTokens(i int) {
	m.output_tokens = &i
	m.addoutput_tokens = nil
}

// OutputTokens returns the value of the "output_tokens" field in the mutation.
func (m *LLMRequestEventMutation) OutputTokens() (r int, exists bool) {
	v := m.output_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputTokens returns the old "output_tokens" field's value of the LLMRequestEvent entity.
// If the LLMRequestEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMRequestEventMutation) OldOutputTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputTokens: %w", err)
	}
	return oldValue.OutputTokens, nil
}

// AddOutputTokens adds i to the "output_tokens" field.
func (m *LLMRequestEventMutation) AddOutputTokens(i int) {
	if m.addoutput_tokens != nil {
		*m.addoutput_tokens += i
	} else {
		m.addoutput_tokens = &i
	}
}

// AddedOutputTokens returns the value that was added to the "output_tokens" field in this mutation.
func (m *LLMRequestEventMutation) AddedOutputTokens() (r int, exists bool) {
	v := m.addoutput_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutputTokens resets all changes to the "output_tokens" field.
func (m *LLMRequestEventMutation) ResetOutputTokens() {
	m.output_tokens = nil
	m.addoutput_tokens = nil
}

// SetLatencyMs sets the "latency_ms" field.
func (m *LLMRequestEventMutation) SetLatencyMs(i int64) {
	m.latency_ms = &i
	m.addlatency_ms = nil
}

// LatencyMs returns the value of the "latency_ms" field in the mutation.
func (m *LLMRequestEventMutation) LatencyMs() (r int64, exists bool) {
	v := m.latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldLatencyMs returns the old "latency_ms" field's value of the LLMRequestEvent entity.
// If the LLMRequestEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMRequestEventMutation) OldLatencyMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatencyMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatencyMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatencyMs: %w", err)
	}
	return oldValue.LatencyMs, nil
}

// AddLatencyMs adds i to the "latency_ms" field.
func (m *LLMRequestEventMutation) AddLatencyMs(i int64) {
	if m.addlatency_ms != nil {
		*m.addlatency_ms += i
	} else {
		m.addlatency_ms = &i
	}
}

// AddedLatencyMs returns the value that was added to the "latency_ms" field in this mutation.
func (m *LLMRequestEventMutation) AddedLatencyMs() (r int64, exists bool) {
	v := m.addlatency_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetLatencyMs resets all changes to the "latency_ms" field.
func (m *LLMRequestEventMutation) ResetLatencyMs() {
	m.latency_ms = nil
	m.addlatency_ms = nil
}

// SetSuccess sets the "success" field.
func (m *LLMRequestEventMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *LLMRequestEventMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the LLMRequestEvent entity.
// If the LLMRequestEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMRequestEventMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *LLMRequestEventMutation) ResetSuccess() {
	m.success = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *LLMRequestEventMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *LLMRequestEventMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the LLMRequestEvent entity.
// If the LLMRequestEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMRequestEventMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *LLMRequestEventMutation) ResetErrorMessage() {
	m.error_message = nil
}

// Where appends a list predicates to the LLMRequestEventMutation builder.
func (m *LLMRequestEventMutation) Where(ps ...predicate.LLMRequestEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LLMRequestEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LLMRequestEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LLMRequestEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LLMRequestEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LLMRequestEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LLMRequestEvent).
func (m *LLMRequestEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LLMRequestEventMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.sequence != nil {
		fields = append(fields, llmrequestevent.FieldSequence)
	}
	if m.timestamp != nil {
		fields = append(fields, llmrequestevent.FieldTimestamp)
	}
	if m.provider != nil {
		fields = append(fields, llmrequestevent.FieldProvider)
	}
	if m.model != nil {
		fields = append(fields, llmrequestevent.FieldModel)
	}
	if m.purpose != nil {
		fields = append(fields, llmrequestevent.FieldPurpose)
	}
	if m.input_tokens != nil {
		fields = append(fields, llmrequestevent.FieldInputTokens)
	}
	if m.output_tokens != nil {
		fields = append(fields, llmrequestevent.FieldOutputTokens)
	}
	if m.latency_ms != nil {
		fields = append(fields, llmrequestevent.FieldLatencyMs)
	}
	if m.success != nil {
		fields = append(fields, llmrequestevent.FieldSuccess)
	}
	if m.error_message != nil {
		fields = append(fields, llmrequestevent.FieldErrorMessage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LLMRequestEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case llmrequestevent.FieldSequence:
		return m.Sequence()
	case llmrequestevent.FieldTimestamp:
		return m.Timestamp()
	case llmrequestevent.FieldProvider:
		return m.Provider()
	case llmrequestevent.FieldModel:
		return m.Model()
	case llmrequestevent.FieldPurpose:
		return m.Purpose()
	case llmrequestevent.FieldInputTokens:
		return m.InputTokens()
	case llmrequestevent.FieldOutputTokens:
		return m.OutputTokens()
	case llmrequestevent.FieldLatencyMs:
		return m.LatencyMs()
	case llmrequestevent.FieldSuccess:
		return m.Success()
	case llmrequestevent.FieldErrorMessage:
		return m.ErrorMessage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LLMRequestEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case llmrequestevent.FieldSequence:
		return m.OldSequence(ctx)
	case llmrequestevent.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case llmrequestevent.FieldProvider:
		return m.OldProvider(ctx)
	case llmrequestevent.FieldModel:
		return m.OldModel(ctx)
	case llmrequestevent.FieldPurpose:
		return m.OldPurpose(ctx)
	case llmrequestevent.FieldInputTokens:
		return m.OldInputTokens(ctx)
	case llmrequestevent.FieldOutputTokens:
		return m.OldOutputTokens(ctx)
	case llmrequestevent.FieldLatencyMs:
		return m.OldLatencyMs(ctx)
	case llmrequestevent.FieldSuccess:
		return m.OldSuccess(ctx)
	case llmrequestevent.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	}
	return nil, fmt.Errorf("unknown LLMRequestEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LLMRequestEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case llmrequestevent.FieldSequence:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequence(v)
		return nil
	case llmrequestevent.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case llmrequestevent.FieldProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case llmrequestevent.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case llmrequestevent.FieldPurpose:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurpose(v)
		return nil
	case llmrequestevent.FieldInputTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputTokens(v)
		return nil
	case llmrequestevent.FieldOutputTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputTokens(v)
		return nil
	case llmrequestevent.FieldLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatencyMs(v)
		return nil
	case llmrequestevent.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case llmrequestevent.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	}
	return fmt.Errorf("unknown LLMRequestEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LLMRequestEventMutation) AddedFields() []string {
	var fields []string
	if m.addsequence != nil {
		fields = append(fields, llmrequestevent.FieldSequence)
	}
	if m.addinput_tokens != nil {
		fields = append(fields, llmrequestevent.FieldInputTokens)
	}
	if m.addoutput_tokens != nil {
		fields = append(fields, llmrequestevent.FieldOutputTokens)
	}
	if m.addlatency_ms != nil {
		fields = append(fields, llmrequestevent.FieldLatencyMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LLMRequestEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case llmrequestevent.FieldSequence:
		return m.AddedSequence()
	case llmrequestevent.FieldInputTokens:
		return m.AddedInputTokens()
	case llmrequestevent.FieldOutputTokens:
		return m.AddedOutputTokens()
	case llmrequestevent.FieldLatencyMs:
		return m.AddedLatencyMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LLMRequestEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case llmrequestevent.FieldSequence:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequence(v)
		return nil
	case llmrequestevent.FieldInputTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInputTokens(v)
		return nil
	case llmrequestevent.FieldOutputTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutputTokens(v)
		return nil
	case llmrequestevent.FieldLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatencyMs(v)
		return nil
	}
	return fmt.Errorf("unknown LLMRequestEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LLMRequestEventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LLMRequestEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LLMRequestEventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LLMRequestEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LLMRequestEventMutation) ResetField(name string) error {
	switch name {
	case llmrequestevent.FieldSequence:
		m.ResetSequence()
		return nil
	case llmrequestevent.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case llmrequestevent.FieldProvider:
		m.ResetProvider()
		return nil
	case llmrequestevent.FieldModel:
		m.ResetModel()
		return nil
	case llmrequestevent.FieldPurpose:
		m.ResetPurpose()
		return nil
	case llmrequestevent.FieldInputTokens:
		m.ResetInputTokens()
		return nil
	case llmrequestevent.FieldOutputTokens:
		m.ResetOutputTokens()
		return nil
	case llmrequestevent.FieldLatencyMs:
		m.ResetLatencyMs()
		return nil
	case llmrequestevent.FieldSuccess:
		m.ResetSuccess()
		return nil
	case llmrequestevent.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown LLMRequestEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LLMRequestEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LLMRequestEventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LLMRequestEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LLMRequestEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LLMRequestEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LLMRequestEventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LLMRequestEventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown LLMRequestEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LLMRequestEventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown LLMRequestEvent edge %s", name)
}

// MasteryEventMutation represents an operation that mutates the MasteryEvent nodes in the graph.
type MasteryEventMutation struct {
	config
	op               Op
	typ              string
	id               *int
	sequence         *int64
	addsequence      *int64
	timestamp        *time.Time
	skill_id         *string
	from_state       *string
	to_state         *string
	trigger          *string
	fluency_score    *float64
	addfluency_score *float64
	session_id       *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*MasteryEvent, error)
	predicates       []predicate.MasteryEvent
}

var _ ent.Mutation = (*MasteryEventMutation)(nil)

// masteryeventOption allows management of the mutation configuration using functional options.
type masteryeventOption func(*MasteryEventMutation)

// newMasteryEventMutation creates new mutation for the MasteryEvent entity.
func newMasteryEventMutation(c config, op Op, opts ...masteryeventOption) *MasteryEventMutation {
	m := &MasteryEventMutation{
		config:        c,
		op:            op,
		typ:           TypeMasteryEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMasteryEventID sets the ID field of the mutation.
func withMasteryEventID(id int) masteryeventOption {
	return func(m *MasteryEventMutation) {
		var (
			err   error
			once  sync.Once
			value *MasteryEvent
		)
		m.oldValue = func(ctx context.Context) (*MasteryEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MasteryEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMasteryEvent sets the old MasteryEvent of the mutation.
func withMasteryEvent(node *MasteryEvent) masteryeventOption {
	return func(m *MasteryEventMutation) {
		m.oldValue = func(context.Context) (*MasteryEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MasteryEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MasteryEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MasteryEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MasteryEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MasteryEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSequence sets the "sequence" field.
func (m *MasteryEventMutation) SetSequence(i int64) {
	m.sequence = &i
	m.addsequence = nil
}

// Sequence returns the value of the "sequence" field in the mutation.
func (m *MasteryEventMutation) Sequence() (r int64, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequence returns the old "sequence" field's value of the MasteryEvent entity.
// If the MasteryEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasteryEventMutation) OldSequence(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequence: %w", err)
	}
	return oldValue.Sequence, nil
}

// AddSequence adds i to the "sequence" field.
func (m *MasteryEventMutation) AddSequence(i int64) {
	if m.addsequence != nil {
		*m.addsequence += i
	} else {
		m.addsequence = &i
	}
}

// AddedSequence returns the value that was added to the "sequence" field in this mutation.
func (m *MasteryEventMutation) AddedSequence() (r int64, exists bool) {
	v := m.addsequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequence resets all changes to the "sequence" field.
func (m *MasteryEventMutation) ResetSequence() {
	m.sequence = nil
	m.addsequence = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *MasteryEventMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *MasteryEventMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the MasteryEvent entity.
// If the MasteryEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasteryEventMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *MasteryEventMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetSkillID sets the "skill_id" field.
func (m *MasteryEventMutation) SetSkillID(s string) {
	m.skill_id = &s
}

// SkillID returns the value of the "skill_id" field in the mutation.
func (m *MasteryEventMutation) SkillID() (r string, exists bool) {
	v := m.skill_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSkillID returns the old "skill_id" field's value of the MasteryEvent entity.
// If the MasteryEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasteryEventMutation) OldSkillID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkillID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkillID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkillID: %w", err)
	}
	return oldValue.SkillID, nil
}

// ResetSkillID resets all changes to the "skill_id" field.
func (m *MasteryEventMutation) ResetSkillID() {
	m.skill_id = nil
}

// SetFromState sets the "from_state" field.
func (m *MasteryEventMutation) SetFromState(s string) {
	m.from_state = &s
}

// FromState returns the value of the "from_state" field in the mutation.
func (m *MasteryEventMutation) FromState() (r string, exists bool) {
	v := m.from_state
	if v == nil {
		return
	}
	return *v, true
}

// OldFromState returns the old "from_state" field's value of the MasteryEvent entity.
// If the MasteryEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasteryEventMutation) OldFromState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromState: %w", err)
	}
	return oldValue.FromState, nil
}

// ResetFromState resets all changes to the "from_state" field.
func (m *MasteryEventMutation) ResetFromState() {
	m.from_state = nil
}

// SetToState sets the "to_state" field.
func (m *MasteryEventMutation) SetToState(s string) {
	m.to_state = &s
}

// ToState returns the value of the "to_state" field in the mutation.
func (m *MasteryEventMutation) ToState() (r string, exists bool) {
	v := m.to_state
	if v == nil {
		return
	}
	return *v, true
}

// OldToState returns the old "to_state" field's value of the MasteryEvent entity.
// If the MasteryEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasteryEventMutation) OldToState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToState: %w", err)
	}
	return oldValue.ToState, nil
}

// ResetToState resets all changes to the "to_state" field.
func (m *MasteryEventMutation) ResetToState() {
	m.to_state = nil
}

// SetTrigger sets the "trigger" field.
func (m *MasteryEventMutation) SetTrigger(s string) {
	m.trigger = &s
}

// Trigger returns the value of the "trigger" field in the mutation.
func (m *MasteryEventMutation) Trigger() (r string, exists bool) {
	v := m.trigger
	if v == nil {
		return
	}
	return *v, true
}

// OldTrigger returns the old "trigger" field's value of the MasteryEvent entity.
// If the MasteryEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasteryEventMutation) OldTrigger(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrigger is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrigger requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrigger: %w", err)
	}
	return oldValue.Trigger, nil
}

// ResetTrigger resets all changes to the "trigger" field.
func (m *MasteryEventMutation) ResetTrigger() {
	m.trigger = nil
}

// SetFluencyScore sets the "fluency_score" field.
func (m *MasteryEventMutation) SetFluencyScore(f float64) {
	m.fluency_score = &f
	m.addfluency_score = nil
}

// FluencyScore returns the value of the "fluency_score" field in the mutation.
func (m *MasteryEventMutation) FluencyScore() (r float64, exists bool) {
	v := m.fluency_score
	if v == nil {
		return
	}
	return *v, true
}

// OldFluencyScore returns the old "fluency_score" field's value of the MasteryEvent entity.
// If the MasteryEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasteryEventMutation) OldFluencyScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFluencyScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFluencyScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFluencyScore: %w", err)
	}
	return oldValue.FluencyScore, nil
}

// AddFluencyScore adds f to the "fluency_score" field.
func (m *MasteryEventMutation) AddFluencyScore(f float64) {
	if m.addfluency_score != nil {
		*m.addfluency_score += f
	} else {
		m.addfluency_score = &f
	}
}

// AddedFluencyScore returns the value that was added to the "fluency_score" field in this mutation.
func (m *MasteryEventMutation) AddedFluencyScore() (r float64, exists bool) {
	v := m.addfluency_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetFluencyScore resets all changes to the "fluency_score" field.
func (m *MasteryEventMutation) ResetFluencyScore() {
	m.fluency_score = nil
	m.addfluency_score = nil
}

// SetSessionID sets the "session_id" field.
func (m *MasteryEventMutation) SetSessionID(s string) {
	m.session_id = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *MasteryEventMutation) SessionID() (r string, exists bool) {
	v := m.session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the MasteryEvent entity.
// If the MasteryEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasteryEventMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ClearSessionID clears the value of the "session_id" field.
func (m *MasteryEventMutation) ClearSessionID() {
	m.session_id = nil
	m.clearedFields[masteryevent.FieldSessionID] = struct{}{}
}

// SessionIDCleared returns if the "session_id" field was cleared in this mutation.
func (m *MasteryEventMutation) SessionIDCleared() bool {
	_, ok := m.clearedFields[masteryevent.FieldSessionID]
	return ok
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *MasteryEventMutation) ResetSessionID() {
	m.session_id = nil
	delete(m.clearedFields, masteryevent.FieldSessionID)
}

// Where appends a list predicates to the MasteryEventMutation builder.
func (m *MasteryEventMutation) Where(ps ...predicate.MasteryEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MasteryEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MasteryEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MasteryEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MasteryEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MasteryEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MasteryEvent).
func (m *MasteryEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MasteryEventMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.sequence != nil {
		fields = append(fields, masteryevent.FieldSequence)
	}
	if m.timestamp != nil {
		fields = append(fields, masteryevent.FieldTimestamp)
	}
	if m.skill_id != nil {
		fields = append(fields, masteryevent.FieldSkillID)
	}
	if m.from_state != nil {
		fields = append(fields, masteryevent.FieldFromState)
	}
	if m.to_state != nil {
		fields = append(fields, masteryevent.FieldToState)
	}
	if m.trigger != nil {
		fields = append(fields, masteryevent.FieldTrigger)
	}
	if m.fluency_score != nil {
		fields = append(fields, masteryevent.FieldFluencyScore)
	}
	if m.session_id != nil {
		fields = append(fields, masteryevent.FieldSessionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MasteryEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case masteryevent.FieldSequence:
		return m.Sequence()
	case masteryevent.FieldTimestamp:
		return m.Timestamp()
	case masteryevent.FieldSkillID:
		return m.SkillID()
	case masteryevent.FieldFromState:
		return m.FromState()
	case masteryevent.FieldToState:
		return m.ToState()
	case masteryevent.FieldTrigger:
		return m.Trigger()
	case masteryevent.FieldFluencyScore:
		return m.FluencyScore()
	case masteryevent.FieldSessionID:
		return m.SessionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MasteryEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case masteryevent.FieldSequence:
		return m.OldSequence(ctx)
	case masteryevent.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case masteryevent.FieldSkillID:
		return m.OldSkillID(ctx)
	case masteryevent.FieldFromState:
		return m.OldFromState(ctx)
	case masteryevent.FieldToState:
		return m.OldToState(ctx)
	case masteryevent.FieldTrigger:
		return m.OldTrigger(ctx)
	case masteryevent.FieldFluencyScore:
		return m.OldFluencyScore(ctx)
	case masteryevent.FieldSessionID:
		return m.OldSessionID(ctx)
	}
	return nil, fmt.Errorf("unknown MasteryEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MasteryEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case masteryevent.FieldSequence:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequence(v)
		return nil
	case masteryevent.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case masteryevent.FieldSkillID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkillID(v)
		return nil
	case masteryevent.FieldFromState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromState(v)
		return nil
	case masteryevent.FieldToState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToState(v)
		return nil
	case masteryevent.FieldTrigger:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrigger(v)
		return nil
	case masteryevent.FieldFluencyScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFluencyScore(v)
		return nil
	case masteryevent.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	}
	return fmt.Errorf("unknown MasteryEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MasteryEventMutation) AddedFields() []string {
	var fields []string
	if m.addsequence != nil {
		fields = append(fields, masteryevent.FieldSequence)
	}
	if m.addfluency_score != nil {
		fields = append(fields, masteryevent.FieldFluencyScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MasteryEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case masteryevent.FieldSequence:
		return m.AddedSequence()
	case masteryevent.FieldFluencyScore:
		return m.AddedFluencyScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MasteryEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case masteryevent.FieldSequence:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequence(v)
		return nil
	case masteryevent.FieldFluencyScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFluencyScore(v)
		return nil
	}
	return fmt.Errorf("unknown MasteryEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MasteryEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(masteryevent.FieldSessionID) {
		fields = append(fields, masteryevent.FieldSessionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MasteryEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MasteryEventMutation) ClearField(name string) error {
	switch name {
	case masteryevent.FieldSessionID:
		m.ClearSessionID()
		return nil
	}
	return fmt.Errorf("unknown MasteryEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MasteryEventMutation) ResetField(name string) error {
	switch name {
	case masteryevent.FieldSequence:
		m.ResetSequence()
		return nil
	case masteryevent.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case masteryevent.FieldSkillID:
		m.ResetSkillID()
		return nil
	case masteryevent.FieldFromState:
		m.ResetFromState()
		return nil
	case masteryevent.FieldToState:
		m.ResetToState()
		return nil
	case masteryevent.FieldTrigger:
		m.ResetTrigger()
		return nil
	case masteryevent.FieldFluencyScore:
		m.ResetFluencyScore()
		return nil
	case masteryevent.FieldSessionID:
		m.ResetSessionID()
		return nil
	}
	return fmt.Errorf("unknown MasteryEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MasteryEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MasteryEventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MasteryEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MasteryEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MasteryEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MasteryEventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MasteryEventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MasteryEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MasteryEventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MasteryEvent edge %s", name)
}

// SessionEventMutation represents an operation that mutates the SessionEvent nodes in the graph.
type SessionEventMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	sequence            *int64
	addsequence         *int64
	timestamp           *time.Time
	session_id          *string
	action              *string
	questions_served    *int
	addquestions_served *int
	correct_answers     *int
	addcorrect_answers  *int
	duration_secs       *int
	addduration_secs    *int
	plan_summary        *[]schema.PlanSlotSummary
	appendplan_summary  []schema.PlanSlotSummary
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*SessionEvent, error)
	predicates          []predicate.SessionEvent
}

var _ ent.Mutation = (*SessionEventMutation)(nil)

// sessioneventOption allows management of the mutation configuration using functional options.
type sessioneventOption func(*SessionEventMutation)

// newSessionEventMutation creates new mutation for the SessionEvent entity.
func newSessionEventMutation(c config, op Op, opts ...sessioneventOption) *SessionEventMutation {
	m := &SessionEventMutation{
		config:        c,
		op:            op,
		typ:           TypeSessionEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionEventID sets the ID field of the mutation.
func withSessionEventID(id int) sessioneventOption {
	return func(m *SessionEventMutation) {
		var (
			err   error
			once  sync.Once
			value *SessionEvent
		)
		m.oldValue = func(ctx context.Context) (*SessionEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SessionEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSessionEvent sets the old SessionEvent of the mutation.
func withSessionEvent(node *SessionEvent) sessioneventOption {
	return func(m *SessionEventMutation) {
		m.oldValue = func(context.Context) (*SessionEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SessionEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSequence sets the "sequence" field.
func (m *SessionEventMutation) SetSequence(i int64) {
	m.sequence = &i
	m.addsequence = nil
}

// Sequence returns the value of the "sequence" field in the mutation.
func (m *SessionEventMutation) Sequence() (r int64, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequence returns the old "sequence" field's value of the SessionEvent entity.
// If the SessionEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionEventMutation) OldSequence(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequence: %w", err)
	}
	return oldValue.Sequence, nil
}

// AddSequence adds i to the "sequence" field.
func (m *SessionEventMutation) AddSequence(i int64) {
	if m.addsequence != nil {
		*m.addsequence += i
	} else {
		m.addsequence = &i
	}
}

// AddedSequence returns the value that was added to the "sequence" field in this mutation.
func (m *SessionEventMutation) AddedSequence() (r int64, exists bool) {
	v := m.addsequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequence resets all changes to the "sequence" field.
func (m *SessionEventMutation) ResetSequence() {
	m.sequence = nil
	m.addsequence = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *SessionEventMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *SessionEventMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the SessionEvent entity.
// If the SessionEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionEventMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *SessionEventMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetSessionID sets the "session_id" field.
func (m *SessionEventMutation) SetSessionID(s string) {
	m.session_id = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *SessionEventMutation) SessionID() (r string, exists bool) {
	v := m.session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the SessionEvent entity.
// If the SessionEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionEventMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *SessionEventMutation) ResetSessionID() {
	m.session_id = nil
}

// SetAction sets the "action" field.
func (m *SessionEventMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *SessionEventMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the SessionEvent entity.
// If the SessionEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionEventMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *SessionEventMutation) ResetAction() {
	m.action = nil
}

// SetQuestionsServed sets the "questions_served" field.
func (m *SessionEventMutation) SetQuestionsServed(i int) {
	m.questions_served = &i
	m.addquestions_served = nil
}

// QuestionsServed returns the value of the "questions_served" field in the mutation.
func (m *SessionEventMutation) QuestionsServed() (r int, exists bool) {
	v := m.questions_served
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionsServed returns the old "questions_served" field's value of the SessionEvent entity.
// If the SessionEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionEventMutation) OldQuestionsServed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuestionsServed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuestionsServed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionsServed: %w", err)
	}
	return oldValue.QuestionsServed, nil
}

// AddQuestionsServed adds i to the "questions_served" field.
func (m *SessionEventMutation) AddQuestionsServed(i int) {
	if m.addquestions_served != nil {
		*m.addquestions_served += i
	} else {
		m.addquestions_served = &i
	}
}

// AddedQuestionsServed returns the value that was added to the "questions_served" field in this mutation.
func (m *SessionEventMutation) AddedQuestionsServed() (r int, exists bool) {
	v := m.addquestions_served
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuestionsServed resets all changes to the "questions_served" field.
func (m *SessionEventMutation) ResetQuestionsServed() {
	m.questions_served = nil
	m.addquestions_served = nil
}

// SetCorrectAnswers sets the "correct_answers" field.
func (m *SessionEventMutation) SetCorrectAnswers(i int) {
	m.correct_answers = &i
	m.addcorrect_answers = nil
}

// CorrectAnswers returns the value of the "correct_answers" field in the mutation.
func (m *SessionEventMutation) CorrectAnswers() (r int, exists bool) {
	v := m.correct_answers
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrectAnswers returns the old "correct_answers" field's value of the SessionEvent entity.
// If the SessionEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionEventMutation) OldCorrectAnswers(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrectAnswers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrectAnswers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrectAnswers: %w", err)
	}
	return oldValue.CorrectAnswers, nil
}

// AddCorrectAnswers adds i to the "correct_answers" field.
func (m *SessionEventMutation) AddCorrectAnswers(i int) {
	if m.addcorrect_answers != nil {
		*m.addcorrect_answers += i
	} else {
		m.addcorrect_answers = &i
	}
}

// AddedCorrectAnswers returns the value that was added to the "correct_answers" field in this mutation.
func (m *SessionEventMutation) AddedCorrectAnswers() (r int, exists bool) {
	v := m.addcorrect_answers
	if v == nil {
		return
	}
	return *v, true
}

// ResetCorrectAnswers resets all changes to the "correct_answers" field.
func (m *SessionEventMutation) ResetCorrectAnswers() {
	m.correct_answers = nil
	m.addcorrect_answers = nil
}

// SetDurationSecs sets the "duration_secs" field.
func (m *SessionEventMutation) SetDurationSecs(i int) {
	m.duration_secs = &i
	m.addduration_secs = nil
}

// DurationSecs returns the value of the "duration_secs" field in the mutation.
func (m *SessionEventMutation) DurationSecs() (r int, exists bool) {
	v := m.duration_secs
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationSecs returns the old "duration_secs" field's value of the SessionEvent entity.
// If the SessionEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionEventMutation) OldDurationSecs(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationSecs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationSecs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationSecs: %w", err)
	}
	return oldValue.DurationSecs, nil
}

// AddDurationSecs adds i to the "duration_secs" field.
func (m *SessionEventMutation) AddDurationSecs(i int) {
	if m.addduration_secs != nil {
		*m.addduration_secs += i
	} else {
		m.addduration_secs = &i
	}
}

// AddedDurationSecs returns the value that was added to the "duration_secs" field in this mutation.
func (m *SessionEventMutation) AddedDurationSecs() (r int, exists bool) {
	v := m.addduration_secs
	if v == nil {
		return
	}
	return *v, true
}

// ResetDurationSecs resets all changes to the "duration_secs" field.
func (m *SessionEventMutation) ResetDurationSecs() {
	m.duration_secs = nil
	m.addduration_secs = nil
}

// SetPlanSummary sets the "plan_summary" field.
func (m *SessionEventMutation) SetPlanSummary(sss []schema.PlanSlotSummary) {
	m.plan_summary = &sss
	m.appendplan_summary = nil
}

// PlanSummary returns the value of the "plan_summary" field in the mutation.
func (m *SessionEventMutation) PlanSummary() (r []schema.PlanSlotSummary, exists bool) {
	v := m.plan_summary
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanSummary returns the old "plan_summary" field's value of the SessionEvent entity.
// If the SessionEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionEventMutation) OldPlanSummary(ctx context.Context) (v []schema.PlanSlotSummary, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanSummary: %w", err)
	}
	return oldValue.PlanSummary, nil
}

// AppendPlanSummary adds sss to the "plan_summary" field.
func (m *SessionEventMutation) AppendPlanSummary(sss []schema.PlanSlotSummary) {
	m.appendplan_summary = append(m.appendplan_summary, sss...)
}

// AppendedPlanSummary returns the list of values that were appended to the "plan_summary" field in this mutation.
func (m *SessionEventMutation) AppendedPlanSummary() ([]schema.PlanSlotSummary, bool) {
	if len(m.appendplan_summary) == 0 {
		return nil, false
	}
	return m.appendplan_summary, true
}

// ClearPlanSummary clears the value of the "plan_summary" field.
func (m *SessionEventMutation) ClearPlanSummary() {
	m.plan_summary = nil
	m.appendplan_summary = nil
	m.clearedFields[sessionevent.FieldPlanSummary] = struct{}{}
}

// PlanSummaryCleared returns if the "plan_summary" field was cleared in this mutation.
func (m *SessionEventMutation) PlanSummaryCleared() bool {
	_, ok := m.clearedFields[sessionevent.FieldPlanSummary]
	return ok
}

// ResetPlanSummary resets all changes to the "plan_summary" field.
func (m *SessionEventMutation) ResetPlanSummary() {
	m.plan_summary = nil
	m.appendplan_summary = nil
	delete(m.clearedFields, sessionevent.FieldPlanSummary)
}

// Where appends a list predicates to the SessionEventMutation builder.
func (m *SessionEventMutation) Where(ps ...predicate.SessionEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SessionEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SessionEvent).
func (m *SessionEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionEventMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.sequence != nil {
		fields = append(fields, sessionevent.FieldSequence)
	}
	if m.timestamp != nil {
		fields = append(fields, sessionevent.FieldTimestamp)
	}
	if m.session_id != nil {
		fields = append(fields, sessionevent.FieldSessionID)
	}
	if m.action != nil {
		fields = append(fields, sessionevent.FieldAction)
	}
	if m.questions_served != nil {
		fields = append(fields, sessionevent.FieldQuestionsServed)
	}
	if m.correct_answers != nil {
		fields = append(fields, sessionevent.FieldCorrectAnswers)
	}
	if m.duration_secs != nil {
		fields = append(fields, sessionevent.FieldDurationSecs)
	}
	if m.plan_summary != nil {
		fields = append(fields, sessionevent.FieldPlanSummary)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sessionevent.FieldSequence:
		return m.Sequence()
	case sessionevent.FieldTimestamp:
		return m.Timestamp()
	case sessionevent.FieldSessionID:
		return m.SessionID()
	case sessionevent.FieldAction:
		return m.Action()
	case sessionevent.FieldQuestionsServed:
		return m.QuestionsServed()
	case sessionevent.FieldCorrectAnswers:
		return m.CorrectAnswers()
	case sessionevent.FieldDurationSecs:
		return m.DurationSecs()
	case sessionevent.FieldPlanSummary:
		return m.PlanSummary()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sessionevent.FieldSequence:
		return m.OldSequence(ctx)
	case sessionevent.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case sessionevent.FieldSessionID:
		return m.OldSessionID(ctx)
	case sessionevent.FieldAction:
		return m.OldAction(ctx)
	case sessionevent.FieldQuestionsServed:
		return m.OldQuestionsServed(ctx)
	case sessionevent.FieldCorrectAnswers:
		return m.OldCorrectAnswers(ctx)
	case sessionevent.FieldDurationSecs:
		return m.OldDurationSecs(ctx)
	case sessionevent.FieldPlanSummary:
		return m.OldPlanSummary(ctx)
	}
	return nil, fmt.Errorf("unknown SessionEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sessionevent.FieldSequence:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequence(v)
		return nil
	case sessionevent.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case sessionevent.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case sessionevent.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case sessionevent.FieldQuestionsServed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionsServed(v)
		return nil
	case sessionevent.FieldCorrectAnswers:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrectAnswers(v)
		return nil
	case sessionevent.FieldDurationSecs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationSecs(v)
		return nil
	case sessionevent.FieldPlanSummary:
		v, ok := value.([]schema.PlanSlotSummary)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanSummary(v)
		return nil
	}
	return fmt.Errorf("unknown SessionEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionEventMutation) AddedFields() []string {
	var fields []string
	if m.addsequence != nil {
		fields = append(fields, sessionevent.FieldSequence)
	}
	if m.addquestions_served != nil {
		fields = append(fields, sessionevent.FieldQuestionsServed)
	}
	if m.addcorrect_answers != nil {
		fields = append(fields, sessionevent.FieldCorrectAnswers)
	}
	if m.addduration_secs != nil {
		fields = append(fields, sessionevent.FieldDurationSecs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sessionevent.FieldSequence:
		return m.AddedSequence()
	case sessionevent.FieldQuestionsServed:
		return m.AddedQuestionsServed()
	case sessionevent.FieldCorrectAnswers:
		return m.AddedCorrectAnswers()
	case sessionevent.FieldDurationSecs:
		return m.AddedDurationSecs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sessionevent.FieldSequence:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequence(v)
		return nil
	case sessionevent.FieldQuestionsServed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuestionsServed(v)
		return nil
	case sessionevent.FieldCorrectAnswers:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCorrectAnswers(v)
		return nil
	case sessionevent.FieldDurationSecs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationSecs(v)
		return nil
	}
	return fmt.Errorf("unknown SessionEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sessionevent.FieldPlanSummary) {
		fields = append(fields, sessionevent.FieldPlanSummary)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionEventMutation) ClearField(name string) error {
	switch name {
	case sessionevent.FieldPlanSummary:
		m.ClearPlanSummary()
		return nil
	}
	return fmt.Errorf("unknown SessionEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionEventMutation) ResetField(name string) error {
	switch name {
	case sessionevent.FieldSequence:
		m.ResetSequence()
		return nil
	case sessionevent.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case sessionevent.FieldSessionID:
		m.ResetSessionID()
		return nil
	case sessionevent.FieldAction:
		m.ResetAction()
		return nil
	case sessionevent.FieldQuestionsServed:
		m.ResetQuestionsServed()
		return nil
	case sessionevent.FieldCorrectAnswers:
		m.ResetCorrectAnswers()
		return nil
	case sessionevent.FieldDurationSecs:
		m.ResetDurationSecs()
		return nil
	case sessionevent.FieldPlanSummary:
		m.ResetPlanSummary()
		return nil
	}
	return fmt.Errorf("unknown SessionEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionEventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionEventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionEventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SessionEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionEventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SessionEvent edge %s", name)
}

// SnapshotMutation represents an operation that mutates the Snapshot nodes in the graph.
type SnapshotMutation struct {
	config
	op            Op
	typ           string
	id            *int
	sequence      *int64
	addsequence   *int64
	timestamp     *time.Time
	data          *map[string]interface{}
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Snapshot, error)
	predicates    []predicate.Snapshot
}

var _ ent.Mutation = (*SnapshotMutation)(nil)

// snapshotOption allows management of the mutation configuration using functional options.
type snapshotOption func(*SnapshotMutation)

// newSnapshotMutation creates new mutation for the Snapshot entity.
func newSnapshotMutation(c config, op Op, opts ...snapshotOption) *SnapshotMutation {
	m := &SnapshotMutation{
		config:        c,
		op:            op,
		typ:           TypeSnapshot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSnapshotID sets the ID field of the mutation.
func withSnapshotID(id int) snapshotOption {
	return func(m *SnapshotMutation) {
		var (
			err   error
			once  sync.Once
			value *Snapshot
		)
		m.oldValue = func(ctx context.Context) (*Snapshot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Snapshot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSnapshot sets the old Snapshot of the mutation.
func withSnapshot(node *Snapshot) snapshotOption {
	return func(m *SnapshotMutation) {
		m.oldValue = func(context.Context) (*Snapshot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SnapshotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SnapshotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SnapshotMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SnapshotMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Snapshot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSequence sets the "sequence" field.
func (m *SnapshotMutation) SetSequence(i int64) {
	m.sequence = &i
	m.addsequence = nil
}

// Sequence returns the value of the "sequence" field in the mutation.
func (m *SnapshotMutation) Sequence() (r int64, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequence returns the old "sequence" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldSequence(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequence: %w", err)
	}
	return oldValue.Sequence, nil
}

// AddSequence adds i to the "sequence" field.
func (m *SnapshotMutation) AddSequence(i int64) {
	if m.addsequence != nil {
		*m.addsequence += i
	} else {
		m.addsequence = &i
	}
}

// AddedSequence returns the value that was added to the "sequence" field in this mutation.
func (m *SnapshotMutation) AddedSequence() (r int64, exists bool) {
	v := m.addsequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequence resets all changes to the "sequence" field.
func (m *SnapshotMutation) ResetSequence() {
	m.sequence = nil
	m.addsequence = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *SnapshotMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *SnapshotMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *SnapshotMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetData sets the "data" field.
func (m *SnapshotMutation) SetData(value map[string]interface{}) {
	m.data = &value
}

// Data returns the value of the "data" field in the mutation.
func (m *SnapshotMutation) Data() (r map[string]interface{}, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *SnapshotMutation) ResetData() {
	m.data = nil
}

// Where appends a list predicates to the SnapshotMutation builder.
func (m *SnapshotMutation) Where(ps ...predicate.Snapshot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SnapshotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SnapshotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Snapshot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SnapshotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SnapshotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Snapshot).
func (m *SnapshotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SnapshotMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.sequence != nil {
		fields = append(fields, snapshot.FieldSequence)
	}
	if m.timestamp != nil {
		fields = append(fields, snapshot.FieldTimestamp)
	}
	if m.data != nil {
		fields = append(fields, snapshot.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SnapshotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case snapshot.FieldSequence:
		return m.Sequence()
	case snapshot.FieldTimestamp:
		return m.Timestamp()
	case snapshot.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SnapshotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case snapshot.FieldSequence:
		return m.OldSequence(ctx)
	case snapshot.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case snapshot.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown Snapshot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SnapshotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case snapshot.FieldSequence:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequence(v)
		return nil
	case snapshot.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case snapshot.FieldData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown Snapshot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SnapshotMutation) AddedFields() []string {
	var fields []string
	if m.addsequence != nil {
		fields = append(fields, snapshot.FieldSequence)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SnapshotMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case snapshot.FieldSequence:
		return m.AddedSequence()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SnapshotMutation) AddField(name string, value ent.Value) error {
	switch name {
	case snapshot.FieldSequence:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequence(v)
		return nil
	}
	return fmt.Errorf("unknown Snapshot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SnapshotMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SnapshotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SnapshotMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Snapshot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SnapshotMutation) ResetField(name string) error {
	switch name {
	case snapshot.FieldSequence:
		m.ResetSequence()
		return nil
	case snapshot.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case snapshot.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown Snapshot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SnapshotMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SnapshotMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SnapshotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SnapshotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SnapshotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SnapshotMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SnapshotMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Snapshot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SnapshotMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Snapshot edge %s", name)
}
